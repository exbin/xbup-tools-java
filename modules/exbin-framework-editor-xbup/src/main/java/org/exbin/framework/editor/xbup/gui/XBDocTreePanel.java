/*
 * Copyright (C) ExBin Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.exbin.framework.editor.xbup.gui;

import java.awt.event.ActionListener;
import java.awt.event.FocusListener;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.swing.DropMode;
import javax.swing.JPopupMenu;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import org.exbin.framework.editor.xbup.viewer.DocumentItemSelectionListener;
import org.exbin.framework.editor.xbup.viewer.XbupTreeDocument;
import org.exbin.framework.utils.TestApplication;
import org.exbin.framework.utils.WindowUtils;
import org.exbin.xbup.core.block.XBTBlock;
import org.exbin.xbup.core.catalog.XBACatalog;
import org.exbin.xbup.operation.undo.XBUndoHandler;
import org.exbin.xbup.parser_tree.XBTTreeNode;

/**
 * Panel with document tree visualization.
 *
 * @author ExBin Project (https://exbin.org)
 */
@ParametersAreNonnullByDefault
public class XBDocTreePanel extends javax.swing.JPanel {

    private XbupTreeDocument treeDocument;
    private final XBDocTreeModel mainDocModel;
    private XBDocTreeCellRenderer cellRenderer;

    private XBACatalog catalog;
    private XBUndoHandler undoHandler;
    private final List<ActionListener> updateListeners;

    private final List<DocumentItemSelectionListener> itemSelectionListeners = new ArrayList<>();

    public XBDocTreePanel() {
        super();
        mainDocModel = new XBDocTreeModel();
        cellRenderer = new XBDocTreeCellRenderer();

        initComponents();

        mainTree.setCellRenderer(cellRenderer);
        mainTree.addTreeSelectionListener((TreeSelectionEvent e) -> {
            XBTTreeNode selectedItem = getSelectedItem();
            itemSelectionListeners.forEach((listener) -> {
                listener.itemSelected(selectedItem);
            });
            notifyUpdate();
        });
//        clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        updateListeners = new ArrayList<>();

        /*clipboard.addFlavorListener(new FlavorListener() {
         @Override
         public void flavorsChanged(FlavorEvent e) {
         pasteAction.setEnabled(pasteAction.isEnabled());
         }
         });*/
        mainTree.setDragEnabled(true);
        mainTree.setDropMode(DropMode.USE_SELECTION);

        mainTree.setTransferHandler(new XBDocTreeTransferHandler(this));
//        mainTree.setDropTarget(new );
    }

    private void notifyUpdate() {
        updateListeners.forEach(updateListener -> {
            updateListener.actionPerformed(null);
        });
    }

    public void setTreeDocument(XbupTreeDocument treeDocument) {
        this.treeDocument = treeDocument;
        mainDocModel.setTreeDocument(treeDocument);
        cellRenderer.setTreeDocument(treeDocument);
    }

    public void setCatalog(XBACatalog catalog) {
        this.catalog = catalog;

        if (treeDocument != null) {
            treeDocument.setCatalog(catalog);
        }
    }

    public void setUndoHandler(XBUndoHandler undoHandler) {
        this.undoHandler = undoHandler;
    }

    public void addTreeSelectionListener(TreeSelectionListener listener) {
        mainTree.getSelectionModel().addTreeSelectionListener(listener);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainScrollPane = new javax.swing.JScrollPane();
        mainTree = new javax.swing.JTree();

        setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.LINE_AXIS));

        mainScrollPane.setBorder(null);

        mainTree.setModel(mainDocModel);
        mainTree.setAutoscrolls(true);
        mainTree.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                mainTreeMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                mainTreeMouseReleased(evt);
            }
        });
        mainScrollPane.setViewportView(mainTree);

        add(mainScrollPane);
    }// </editor-fold>//GEN-END:initComponents

    private void mainTreeMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mainTreeMouseReleased
        if (evt.isPopupTrigger()) {
            mainTree.setSelectionPath(mainTree.getPathForLocation(evt.getX(), evt.getY()));
//            boolean availableItem = (mainTree.getLastSelectedPathComponent() != null);
//            setEditEnabled(availableItem);
//            boolean addPossible;
//            if (!availableItem) {
//                addPossible = mainDoc.getRootBlock() == null;
//            } else {
//                addPossible = ((XBTTreeNode) mainTree.getLastSelectedPathComponent()).getDataMode() == XBBlockDataMode.NODE_BLOCK;
//            }
//            setAddEnabled(addPossible);
        }
    }//GEN-LAST:event_mainTreeMouseReleased

    private void mainTreeMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_mainTreeMousePressed
        if (evt.isPopupTrigger()) {
            mainTree.setSelectionPath(mainTree.getPathForLocation(evt.getX(), evt.getY()));
//            boolean availableItem = (mainTree.getLastSelectedPathComponent() != null);
//            setEditEnabled(availableItem);
//            boolean addPossible;
//            if (!availableItem) {
//                addPossible = mainDoc.getRootBlock() == null;
//            } else {
//                addPossible = ((XBTTreeNode) mainTree.getLastSelectedPathComponent()).getDataMode() == XBBlockDataMode.NODE_BLOCK;
//            }
//            setAddEnabled(addPossible);
        }
    }//GEN-LAST:event_mainTreeMousePressed

    @Nullable
    public XBTTreeNode getSelectedItem() {
        return (XBTTreeNode) mainTree.getLastSelectedPathComponent();
    }

    public void reportStructureChange(XBTBlock block) {
        if (block == null) {
            mainDocModel.fireTreeChanged();
        } else {
            mainDocModel.fireTreeStructureChanged(block);
        }
    }

    public void addUpdateListener(ActionListener listener) {
        updateListeners.add(listener);
    }

    public void removeUpdateListener(ActionListener listener) {
        updateListeners.remove(listener);
    }

    public XBACatalog getCatalog() {
        return catalog;
    }

    public void performSelectAll() {
        mainTree.setSelectionRow(0);
    }

    /**
     * Test method for this panel.
     *
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        TestApplication.run(() -> WindowUtils.invokeWindow(new XBDocTreePanel()));
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane mainScrollPane;
    private javax.swing.JTree mainTree;
    // End of variables declaration//GEN-END:variables

    public XBUndoHandler getUndoHandler() {
        return undoHandler;
    }

    public void setPopupMenu(JPopupMenu popupMenu) {
        mainTree.setComponentPopupMenu(popupMenu);
    }

    public void addItemSelectionListener(DocumentItemSelectionListener listener) {
        itemSelectionListeners.add(listener);
    }

    public void removeItemSelectionListener(DocumentItemSelectionListener listener) {
        itemSelectionListeners.remove(listener);
    }

    public boolean hasSelection() {
        return !mainTree.isSelectionEmpty();
    }

    public void addTreeFocusListener(FocusListener focusListener) {
        mainTree.addFocusListener(focusListener);
    }

    public void removeTreeFocusListener(FocusListener focusListener) {
        mainTree.removeFocusListener(focusListener);
    }
}
